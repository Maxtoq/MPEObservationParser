import argparse
import keyboard
import random
import json
import time
import numpy as np

# from utils.embedding.ngram import embedding
from utils.make_env import make_env
from utils.actors import KeyboardActor, RandomActor
from utils.analyse import analyze
from utils.render_option import Render_option
from utils.utils import save
from utils.utils import execution_time


def run(args):
    # Load scenario config
    sce_conf = {}
    if args.sce_conf_path is not None:
        with open(args.sce_conf_path) as cf:
            sce_conf = json.load(cf)

    # Create environment
    env, parser = make_env(
        args, 
        discrete_action=args.discrete_action, 
        sce_conf=sce_conf) 
    nb_agents = env.num_agents

    # Load initial positions if given
    if args.sce_init_pos is not None:
        with open(args.sce_init_pos, 'r') as f:
            init_pos_scenar = json.load(f)
    else:
        init_pos_scenar = None

    if args.actors == "manual" :
        actor = KeyboardActor(nb_agents)
    elif args.actors == "random" :
        actor = RandomActor(nb_agents)
    else:
        print("ERROR : Pick correct actors (random or manual)")
        exit(0)
    

    # -------------- UTILE ? ----------
    # Get the color and shape if needed
    colors = []
    shapes = []    

    # Save all the sentences generated
    sentences = []
    for nb_agent in range(nb_agents):
        newAgent = []
        sentences.append(newAgent)

    # Save all the observations generated
    observations = []
    # Save all the actions genenrated
    action_list = []

    render_op = Render_option()

    for ep_i in range(args.n_episodes):
        # Reset the environment
        obs = env.reset(init_pos=init_pos_scenar)

        # # Get the colors and the shapes of the episode
        # obj_colors = []
        # obj_shapes = []
        # land_colors = []
        # land_shapes = []
        # if hasattr(env.world, 'objects'):
        #    # Get the color and the shape
        #     for object in env.world.objects :
        #         obj_colors.append(object.num_color)
        #         obj_shapes.append(object.num_shape)
        #     for land in env.world.landmarks :
        #         land_colors.append(land.num_color)
        #         land_shapes.append(land.num_shape)

        # if parser is not None:
        #     parser.reset(obj_colors, obj_shapes, land_colors, land_shapes)
        for step_i in range(args.ep_length):
            print("Step", step_i)
            print("Observations:", obs)
            # Get action
            actions = actor.get_action()
            print("Actions:", actions)
            next_obs, rewards, dones, infos = env.step(actions)
            print("Rewards:", rewards)
            if parser is not None:
                # Get sentence of the agents
                for agent in range(nb_agents):
                    print("Agent " + str(agent) + ":")
                    # Call the right parser
                    if args.parser == "basic":
                        sentence = parser.parse_obs(obs[agent])
                    elif args.parser == 'strat':
                        sentence = parser.parse_obs(obs[agent], agent)
                    print(sentence)
                    sentences[agent].append(sentence)

            observations.append(obs)
            action_list.append(actions)

            # # Get the render option
            # range1, range2 = render_op.modify_option()

            env.render()
            time.sleep(args.step_time)

            if dones[0]:
                break
            obs = next_obs
    
    env.close()
    # Analysis of the sentences generated
    print("Would you like to see the analysis ?")
    print("Press A to see the analysis")
    print("Press any key to quit")
    if keyboard.read_key() == "a":
        analyze(sentences)
    else:
        # Clear the buffer
        keyboard.read_key()

    # Saves the data generated by the exercise in a json file
    print("Would you like to save the results ?")
    print("Press S to save")
    print("Press any key to quit")
    if keyboard.read_key() == "s":
        save(nb_agents,sentences,observations,action_list)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    # Scenario
    parser.add_argument("--env_path", default="env/coop_push_scenario_sparse.py",
                        help="Path to the environment")
    parser.add_argument("--sce_conf_path", default=None, 
                        type=str, help="Path to the scenario config file")
    parser.add_argument("--sce_init_pos", default=None, 
                        type=str, help="Path to initial positions config file")
    # Environment
    parser.add_argument("--n_episodes", default=1, type=int)
    parser.add_argument("--ep_length", default=1000, type=int)
    parser.add_argument("--discrete_action", action='store_true')
    # Render
    parser.add_argument("--step_time", default=0.1, type=float)
    # Language
    parser.add_argument("--chance_not_sent", default=0.1, type=float)
    parser.add_argument("--parser", default=None, type=str, help="Available parsers are 'basic' and 'strat'")
    # Action
    parser.add_argument("--actors", default="manual", type=str, help="Available actors are 'random' or 'manual'")

    args = parser.parse_args()
    run(args)